{"version":3,"file":"index.mjs","sources":["../../node_modules/p-map/index.js"],"sourcesContent":["export default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true,\n\t\tsignal,\n\t} = {},\n) {\n\treturn new Promise((resolve_, reject_) => {\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst signalListener = () => {\n\t\t\treject(signal.reason);\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tsignal?.removeEventListener('abort', signalListener);\n\t\t};\n\n\t\tconst resolve = value => {\n\t\t\tresolve_(value);\n\t\t\tcleanup();\n\t\t};\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t\tcleanup();\n\t\t};\n\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(signal.reason);\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors)); // eslint-disable-line unicorn/error-message\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (skippedIndexesMap.size === 0) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport function pMapIterable(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tbackpressure = concurrency,\n\t} = {},\n) {\n\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t}\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tif (!((Number.isSafeInteger(backpressure) && backpressure >= concurrency) || backpressure === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`backpressure\\` to be an integer from \\`concurrency\\` (${concurrency}) and up or \\`Infinity\\`, got \\`${backpressure}\\` (${typeof backpressure})`);\n\t}\n\n\treturn {\n\t\tasync * [Symbol.asyncIterator]() {\n\t\t\tconst iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();\n\n\t\t\tconst promises = [];\n\t\t\tlet pendingPromisesCount = 0;\n\t\t\tlet isDone = false;\n\t\t\tlet index = 0;\n\n\t\t\tfunction trySpawn() {\n\t\t\t\tif (isDone || !(pendingPromisesCount < concurrency && promises.length < backpressure)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tpendingPromisesCount++;\n\n\t\t\t\tconst promise = (async () => {\n\t\t\t\t\tconst {done, value} = await iterator.next();\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tpendingPromisesCount--;\n\t\t\t\t\t\treturn {done: true};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Spawn if still below concurrency and backpressure limit\n\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst returnValue = await mapper(await value, index++);\n\n\t\t\t\t\t\tpendingPromisesCount--;\n\n\t\t\t\t\t\tif (returnValue === pMapSkip) {\n\t\t\t\t\t\t\tconst index = promises.indexOf(promise);\n\n\t\t\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t\t\tpromises.splice(index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Spawn if still below backpressure limit and just dropped below concurrency limit\n\t\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\t\treturn {done: false, value: returnValue};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tpendingPromisesCount--;\n\t\t\t\t\t\tisDone = true;\n\t\t\t\t\t\treturn {error};\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\tpromises.push(promise);\n\t\t\t}\n\n\t\t\ttrySpawn();\n\n\t\t\twhile (promises.length > 0) {\n\t\t\t\tconst {error, done, value} = await promises[0]; // eslint-disable-line no-await-in-loop\n\n\t\t\t\tpromises.shift();\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tif (done) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Spawn if just dropped below backpressure limit and below the concurrency limit\n\t\t\t\ttrySpawn();\n\n\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tyield value;\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport const pMapSkip = Symbol('skip');\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}